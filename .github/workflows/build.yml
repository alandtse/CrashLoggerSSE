# Copyright (c) 2020-2021-2022 Luca Cappa
# Released under the term specified in file LICENSE.txt
# SPDX short identifier: MIT
#
# The peculiarity of this workflow is that assumes vcpkg is NOT stored as a submodule of this repository.
# This workflow does the following:
# - Restores vcpkg artifacts from cache.
# - Using the provided Git commit id, sets up vcpkg if needed, then run CMake with CMakePreset.json using a configuration
#   that leverages the vcpkg's toolchain file. This will automatically run vcpkg to install dependencies
#   described by the vcpkg.json manifest file. It will be a no-op if those are restored from cache.
# - Finally builds the sources with Ninja.
name: Semantic Release and Build
on:
  push:
    branches:
      - main  # Only release from main branch
  pull_request:  # Build on PRs for testing (no release)
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to upload to Nexus (leave empty for latest release)'
        type: string
        required: false

jobs:
  build:
    name: ${{ matrix.os }}-${{ github.workflow }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [windows-latest]
    if: github.repository_owner == 'alandtse'

    steps:
      - uses: actions/checkout@v4
        with:
          submodules: "recursive"

      - name: Extract vcpkg baseline from vcpkg.json
        id: vcpkg_baseline
        shell: pwsh
        run: |
          $vcpkgJson = Get-Content vcpkg.json | ConvertFrom-Json
          $baseline = $vcpkgJson.'builtin-baseline'
          echo "baseline=$baseline" >> $env:GITHUB_OUTPUT
          echo "âœ“ Using vcpkg baseline from vcpkg.json: $baseline"

      - uses: lukka/get-cmake@latest

      - name: Restore artifacts, or setup vcpkg (do not install any package)
        uses: lukka/run-vcpkg@v10
        id: runvcpkg
        with:
          # This specifies the location of vcpkg, where it is going to be restored from cache, or create from scratch.
          vcpkgDirectory: "${{ runner.workspace }}/b/vcpkg"
          # The Git commit id of vcpkg to be checked out. This is only needed because we are not using a submodule.
          vcpkgGitCommitId: "${{ steps.vcpkg_baseline.outputs.baseline }}"
          # The vcpkg.json file, which will be part of cache key computation.
          vcpkgJsonGlob: "/vcpkg.json"

      - name: Prints output of run-vcpkg's action
        run: echo "root='${{ steps.runvcpkg.outputs.RUNVCPKG_VCPKG_ROOT_OUT }}', triplet='${{ steps.runvcpkg.outputs.RUNVCPKG_VCPKG_DEFAULT_TRIPLET_OUT }}'"

      - name: Setup node
        uses: actions/setup-node@v4
        with:
          node-version: 20
      - name: Semantic Release
        uses: cycjimmy/semantic-release-action@v4
        id: semantic # Need an `id` for output variables
        with:
          # You can specify specifying version range for the extra plugins if you prefer.
          extra_plugins: |
            @semantic-release/changelog
            @semantic-release/git
            @semantic-release/github
            @google/semantic-release-replace-plugin
          dry_run: false
          semantic_version: 24.1.2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Run CMake with vcpkg.json manifest
        if: steps.semantic.outputs.new_release_published == 'true'
        uses: lukka/run-cmake@v10
        with:
          cmakeListsTxtPath: "${{ github.workspace }}/CMakeLists.txt"
          configurePreset: Release-MSVC
          buildPreset: Release-MSVC
      - name: Upload files to a GitHub release
        if: steps.semantic.outputs.new_release_published == 'true'
        uses: svenstaro/upload-release-action@2.3.0
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file_glob: true
          file: build/release-msvc/CrashLogger_${{ steps.semantic.outputs.new_release_version }}.7z
          tag: ${{ steps.semantic.outputs.new_release_git_tag }}
          overwrite: true

    outputs:
      new_release_published: ${{ steps.semantic.outputs.new_release_published }}
      new_release_version: ${{ steps.semantic.outputs.new_release_version }}
      new_release_notes: ${{ steps.semantic.outputs.new_release_notes }}

  upload-to-nexus:
    name: Upload to Nexus Mods
    runs-on: windows-latest
    needs: build
    # Run if: manual trigger OR build created a new release
    if: |
      always() &&
      (github.event_name == 'workflow_dispatch' || needs.build.outputs.new_release_published == 'true') &&
      github.repository_owner == 'alandtse'

    steps:
      - uses: actions/checkout@v4

      - name: Determine version to upload
        id: version
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Manual workflow_dispatch with version input
          $inputVersion = "${{ inputs.version }}"
          # Version from build job (new release)
          $buildVersion = "${{ needs.build.outputs.new_release_version }}"

          if ($inputVersion) {
            $version = $inputVersion
            Write-Output "Using manually specified version: $version"
          } elseif ($buildVersion) {
            $version = $buildVersion
            Write-Output "Using version from build job: $version"
          } else {
            # Auto-detect latest release
            $latestRelease = gh release list --limit 1 --json tagName --jq '.[0].tagName'
            $version = $latestRelease -replace '^v', ''
            Write-Output "Auto-detected latest release: $version"
          }

          Write-Output "VERSION=$version" >> $env:GITHUB_OUTPUT

      - name: Download release artifact
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          $fileName = "CrashLogger_$version.7z"

          Write-Output "Downloading $fileName from release v$version"
          New-Item -ItemType Directory -Force -Path ./download
          gh release download "v$version" --pattern "$fileName" --dir ./download

          if (!(Test-Path "./download/$fileName")) {
            Write-Error "Failed to download $fileName from release v$version"
            exit 1
          }

          Write-Output "Successfully downloaded $fileName"

      - name: Get changelog
        id: changelog
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          $buildNotes = @"
          ${{ needs.build.outputs.new_release_notes }}
          "@

          if ($buildNotes.Trim()) {
            $changelog = $buildNotes
            Write-Output "Using changelog from build job"
          } else {
            # Get from GitHub release
            $changelog = gh release view "v$version" --json body --jq .body
            Write-Output "Using GitHub release notes for v$version"
          }

          $changelog | Out-File -FilePath changelog.txt -Encoding utf8

      - name: Setup Dotnet
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: 8.x.x

      - name: Download NexusUploader
        run: dotnet tool install -g BUTR.NexusUploader

      - name: Refresh Nexus session cookie
        env:
          UNEX_SESSION_COOKIE: ${{ secrets.UNEX_NEXUSMODS_SESSION_COOKIE }}
        run: unex refresh

      - name: Upload file to Nexus
        env:
          UNEX_SESSION_COOKIE: ${{ secrets.UNEX_NEXUSMODS_SESSION_COOKIE }}
          UNEX_APIKEY: ${{ secrets.UNEX_APIKEY }}
          UNEX_GAME: skyrimspecialedition
          UNEX_MODID: 59818
          UNEX_DEBUG: true
          UNEX_FILENAME: CrashLogger
          UNEX_FILEDESCRIPTION: |-
            See Description -> Requirements for installation instructions.
            PDB is for crash debugging and can be removed.
          UNEX_PREVIOUSFILE: "auto"
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          $file = "./download/CrashLogger_$version.7z"

          unex upload $env:UNEX_MODID $file -v $version

      - name: Upload changelog to Nexus
        env:
          UNEX_SESSION_COOKIE: ${{ secrets.UNEX_NEXUSMODS_SESSION_COOKIE }}
          UNEX_APIKEY: ${{ secrets.UNEX_APIKEY }}
          UNEX_GAME: skyrimspecialedition
          UNEX_MODID: 59818
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          $changelog = Get-Content changelog.txt -Raw

          unex changelog $version -c "$changelog"
